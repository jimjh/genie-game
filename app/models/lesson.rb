# == Lesson
# A lesson record in the database _should_ correspond to a lesson directory in
# the filesystem, although for performance reasons that's not enforced.
#
# - +slug+ is generated by friendly_id from +name+.
# - +name+ is the repository's identifier on the provider. It can be any string
#   value, although the controllers (with knowledge of GitHub's conventions)
#   might set this to the repository's name for easier web hooking. This is not
#   validated, because the model should be provider-independent. It defaults to
#   +basename url+.
# - +owner+ is the repository's owner on the provider.
# - +url+ is a cloneable url of the git repository.
# - +hook+ is the ID of a web hook registered with the provider.
# - +status+ is either
#   - +publishing+,
#   - +published+,
#   - +inactive+, or
#   - +failed+
#
# TODO faye
class Lesson < ActiveRecord::Base
  extend FriendlyId
  include GitConcern

  STATUSES = %w[publishing published failed deactivated]

  # callbacks ----------------------------------------------------------------
  before_validation :default_values

  # attributes ---------------------------------------------------------------
  friendly_id       :name, use: :scoped, scope: [:user]
  attr_accessible   :name, :url, :title, :description, :owner
  attr_accessor     :action
  attr_readonly     :user_id

  # relationships ------------------------------------------------------------
  belongs_to :user, inverse_of: :lessons
  has_many   :answers, through: :problems
  with_options dependent: :destroy, inverse_of: :lesson do |assoc|
    assoc.has_many :problems, order: 'digest', autosave: true,
      extend: UpdateProblemsExtension
    assoc.has_many :usages
  end

  # validations --------------------------------------------------------------
  validates_presence_of   :name, :url, :owner, :user
  validates_inclusion_of  :status, in: STATUSES
  validate                :url_must_be_valid

  # scopes -------------------------------------------------------------------
  default_scope order('title')
  scope :published, where(status: 'published')
  scope :for_user, lambda { |user| joins(:user).where('users.slug=?', user) }

  # @return [Pathname] path that is suitable for use as lesson path
  def path
    Pathname.new(user.slug) + self.slug
  end

  def published?
    self.status == 'published'
  end

  def deactivated?
    self.status == 'deactivated'
  end

  # Sets status to +deactivated+.
  # @return [Boolean] success
  def deactivate
    return false if deactivated?
    self.status = 'deactivated'
    save
  end

  # Removes deactivated status and imitates a push.
  # @return [Boolean] success
  def activate
    self.status = ''
    pushed
  end

  # Sets status to +failed+ unless lesson has been deactivated.
  # @return [Boolean] success
  def failed(error = { base: ['lesson.unknown'] })
    return false if deactivated?
    self.status     = 'failed'
    self.last_error = error
    notify_observers :after_fail if (suc = save)
    suc
  end

  # Sets status to +failed+ unless lesson has been deactivated.
  # @return [Boolean] success
  def published(opts)
    return false if deactivated?
    self.compiled_path = opts[:compiled_path]
    self.title         = opts[:title]
    self.description   = opts[:description]
    self.status        = 'published'
    self.problems.update_or_initialize(opts[:problems] || [])
    self.last_error    = nil
    notify_observers :after_publish if (suc = save)
    suc
  end

  # Sets status to +publishing+ unless lesson has been deactivated.
  # @return [Boolean] success
  def pushed
    return false if deactivated?
    self.status = 'publishing'
    notify_observers :after_push if (suc = save)
    suc
  end

  def problem_at(position)
    problems.select([:id, :solution]).find_by_position!(position)
  end

  def answers_for(user)
    answers.select(%w[content problems.position])
      .where('user_id=?', user.id)
      .where('problems.active=?', true)
  end

  # @param [String] subpath     path to desired file relative to lesson root
  # @param [String] format      format of desired file e.g. png, inc
  # @return [Pathname] absolute path to file
  # @raise [RecordNotFound] if the path is invalid or does not point to an
  #   existing file.
  def path_to(subpath, format)
    path = Pathname.new(subpath || '').expand_path(compiled_path)
    path = path.sub_ext('.' + format) unless format.blank?
    unless path.to_s.starts_with?(compiled_path) and path.exist?
      raise ActiveRecord::RecordNotFound,
        "Unable to find file with subpath=#{subpath}.#{format}"
    end
    path
  end

  def last_error_messages
    errors = last_error.is_a?(String) ? YAML.load(last_error) : last_error
    errors.map do |field, value|
      I18n.t value.shift, field: field, args: value.first
    end
  end

  def to_s
    title
  end

  private

  # Checks if the given url is a valid git URL. Local paths with +file://+ are
  # not supported.
  # @note This is not bulletproof, and a hacker and still supply a carefully
  #   crafted string to trick us into cloning a local repository.
  # @see http://www.kernel.org/pub/software/scm/git/docs/git-clone.html
  def url_must_be_valid
    url.blank? ||
      (url_is_remote? and url_has_suffix? and url_matches?) ||
      errors.add(:url, :invalid)
  end

  # Sets default values.
  def default_values
    self.name ||= File.basename(url || '', GitConcern::GIT_SUFFIX)
  end

end
