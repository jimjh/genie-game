# == Lesson
# A lesson record in the database _should_ correspond to a lesson directory in
# the filesystem, although for performance reasons that's not enforced.
#
# - +slug+ is generated by friendly_id from +name+.
# - +name+ is the repositories identifier on the provider. It can be any string
#   value, although the controllers (with knowledge of GitHub's conventions)
#   might set this to the repository's name for easier web hooking. This is not
#   validated, because the model should be provider-independent. It defaults to
#   +basename url+.
# - +url+ is a cloneable url of the git repository.
# - +hook+ is the ID of a web hook registered with the provider.
# - +status+ is either
#   - +publishing+,
#   - +published+, or
#   - +failed+
#
# TODO faye
class Lesson < ActiveRecord::Base
  extend FriendlyId
  include GitConcern

  STATUSES = %w[publishing published failed deactivated]

  # callbacks ----------------------------------------------------------------
  before_validation :default_values

  # attributes ---------------------------------------------------------------
  friendly_id       :name, use: :scoped, scope: [:user]
  attr_accessible   :name, :url, :title, :description
  attr_accessor     :action

  # relationships ------------------------------------------------------------
  belongs_to :user
  has_many   :problems, order: 'digest', dependent: :destroy, autosave: true,
    extend: UpdateProblemsExtension
  has_many   :answers, through: :problems

  # validations --------------------------------------------------------------
  validates_presence_of   :name, :url, :user_id
  validates_uniqueness_of :name, scope: :user_id
  validates_inclusion_of  :status, in: STATUSES
  validates_existence_of  :user
  validate                :url_must_be_valid

  # scopes -------------------------------------------------------------------
  scope :published, where(status: 'published')
  scope :for_user, lambda { |user| joins(:user).where('users.slug=?', user) }

  # @return [Pathname] path that is suitable for use as lesson path
  def path
    Pathname.new(user.slug) + self.slug
  end

  def published?
    self.status == 'published'
  end

  def deactivated?
    self.status == 'deactivated'
  end

  # Sets status to +deactivated+.
  # @return [Boolean] success
  def deactivate
    return false if deactivated?
    self.status = 'deactivated'
    save
  end

  # Removes deactivated status and imitates a push.
  # @return [Boolean] success
  def activate
    self.status = ''
    pushed
  end

  # Sets status to +failed+ unless lesson has been deactivated.
  # @return [Boolean] success
  def failed
    return false if deactivated?
    self.status = 'failed'
    notify_observers :after_fail if (suc = save)
    suc
  end

  # Sets status to +failed+ unless lesson has been deactivated.
  # @return [Boolean] success
  def published(opts)
    return false if deactivated?
    self.compiled_path = opts[:compiled_path]
    self.title         = opts[:title]
    self.description   = opts[:description]
    self.status        = 'published'
    self.problems.update_or_initialize(opts[:problems] || [])
    notify_observers :after_publish if (suc = save)
    suc
  end

  # Sets status to +publishing+ unless lesson has been deactivated.
  # @return [Boolean] success
  def pushed
    return false if deactivated?
    self.status = 'publishing'
    notify_observers :after_push if (suc = save)
    suc
  end

  def problem_at(position)
    problems.select([:id, :solution]).find_by_position!(position)
  end

  def answers_for(user)
    answers.select(%w[content problems.position])
      .where('user_id=?', user.id)
      .where('problems.active=?', true)
  end

  private

  # Checks if the given url is a valid git URL. Local paths with +file://+ are
  # not supported.
  # @note This is not foolproof, and a hacker and still supply a carefully
  #   crafted string to trick us into cloning a local repository.
  # @see http://www.kernel.org/pub/software/scm/git/docs/git-clone.html
  def url_must_be_valid
    url.blank? ||
      (url_is_remote? and url_has_suffix? and url_matches?) ||
      errors.add(:url, 'is not a valid git URL.')
  end

  # Sets default values.
  def default_values
    self.name ||= File.basename(url || '', GitConcern::GIT_SUFFIX)
  end

end
